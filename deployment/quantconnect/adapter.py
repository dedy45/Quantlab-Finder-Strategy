"""
QuantConnect Adapter.

Converts QuantLab strategies to QuantConnect LEAN algorithm format.
"""

import logging
from typing import Any, Callable, Dict, List, Optional

import numpy as np
import pandas as pd
from scipy import stats

from ..base import BaseAdapter, DeploymentConfig, DeploymentResult, PlatformType

logger = logging.getLogger(__name__)

# Alpha Streams requirements
ALPHA_STREAMS_MIN_PSR = 0.95
ALPHA_STREAMS_MAX_CORRELATION = 0.30
ALPHA_STREAMS_MIN_CAPACITY = 1_000_000


class QuantConnectAdapter(BaseAdapter):
    """
    Adapter for QuantConnect platform.
    
    Generates LEAN algorithm code from QuantLab strategies.
    
    Parameters
    ----------
    config : DeploymentConfig, optional
        Deployment configuration
    symbols : List[str], optional
        List of symbols to trade
    resolution : str, optional
        Data resolution: 'daily', 'hour', 'minute'
    """
    
    def __init__(
        self,
        config: Optional[DeploymentConfig] = None,
        symbols: Optional[List[str]] = None,
        resolution: str = 'daily'
    ):
        super().__init__(config)
        self.symbols = symbols or ['SPY', 'QQQ', 'IWM', 'TLT', 'GLD']
        self.resolution = resolution
        
    def convert(
        self,
        strategy_func: Callable,
        **kwargs
    ) -> str:
        """
        Convert strategy to QuantConnect LEAN format.
        
        Parameters
        ----------
        strategy_func : Callable
            Strategy function
        **kwargs
            lookback : int - Lookback period
            rebalance : str - Rebalance frequency
            
        Returns
        -------
        str
            LEAN algorithm Python code
        """
        lookback = kwargs.get('lookback', 20)
        rebalance = kwargs.get('rebalance', 'weekly')
        strategy_name = self.config.strategy_name
        
        logger.info(f"Converting strategy '{strategy_name}' for QuantConnect")
        
        symbols_str = ', '.join([f'"{s}"' for s in self.symbols])
        
        code = f'''"""
{strategy_name} - QuantConnect LEAN Algorithm
Generated by QuantLab v0.4.0

Symbols: {self.symbols}
Resolution: {self.resolution}
Rebalance: {rebalance}
"""

from AlgorithmImports import *
import numpy as np


class {strategy_name.replace(" ", "")}(QCAlgorithm):
    """
    QuantLab Strategy deployed to QuantConnect.
    """
    
    def Initialize(self) -> None:
        """Initialize algorithm."""
        # Basic settings
        self.SetStartDate(2020, 1, 1)
        self.SetCash({int(self.config.initial_capital)})
        
        # Universe
        self.symbols = [{symbols_str}]
        self.securities = {{}}
        
        for symbol in self.symbols:
            equity = self.AddEquity(symbol, Resolution.{self.resolution.capitalize()})
            equity.SetDataNormalizationMode(DataNormalizationMode.Adjusted)
            self.securities[symbol] = equity
        
        # Strategy parameters
        self.lookback = {lookback}
        self.rebalance_freq = "{rebalance}"
        
        # Risk management
        self.max_drawdown = {self.config.max_drawdown}
        self.max_leverage = {self.config.max_leverage}
        
        # History storage
        self.history_window = {{}}
        for symbol in self.symbols:
            self.history_window[symbol] = RollingWindow[float](self.lookback)
        
        # Schedule rebalancing
        if self.rebalance_freq == "daily":
            self.Schedule.On(
                self.DateRules.EveryDay(),
                self.TimeRules.AfterMarketOpen("SPY", 30),
                self.Rebalance
            )
        elif self.rebalance_freq == "weekly":
            self.Schedule.On(
                self.DateRules.Every(DayOfWeek.Monday),
                self.TimeRules.AfterMarketOpen("SPY", 30),
                self.Rebalance
            )
        else:  # monthly
            self.Schedule.On(
                self.DateRules.MonthStart(),
                self.TimeRules.AfterMarketOpen("SPY", 30),
                self.Rebalance
            )
        
        # Warm up
        self.SetWarmUp(self.lookback)
    
    def OnData(self, data: Slice) -> None:
        """Process incoming data."""
        if self.IsWarmingUp:
            return
        
        # Update history windows
        for symbol in self.symbols:
            if data.ContainsKey(symbol) and data[symbol] is not None:
                self.history_window[symbol].Add(float(data[symbol].Close))
    
    def Rebalance(self) -> None:
        """Rebalance portfolio based on strategy signals."""
        if self.IsWarmingUp:
            return
        
        # Check if we have enough data
        for symbol in self.symbols:
            if not self.history_window[symbol].IsReady:
                return
        
        # Calculate signals
        weights = self.CalculateWeights()
        
        # Apply risk management
        weights = self.ApplyRiskManagement(weights)
        
        # Execute trades
        for symbol, weight in weights.items():
            self.SetHoldings(symbol, weight)
    
    def CalculateWeights(self) -> dict:
        """
        Calculate target weights for each symbol.
        
        Returns
        -------
        dict
            Symbol -> weight mapping
        """
        weights = {{}}
        
        # Get historical prices
        prices = {{}}
        for symbol in self.symbols:
            prices[symbol] = list(self.history_window[symbol])[::-1]
        
        # Calculate momentum (example strategy)
        momentum = {{}}
        for symbol in self.symbols:
            if len(prices[symbol]) >= self.lookback:
                returns = np.diff(prices[symbol]) / prices[symbol][:-1]
                momentum[symbol] = np.mean(returns)
            else:
                momentum[symbol] = 0
        
        # Normalize to weights
        total_abs = sum(abs(m) for m in momentum.values())
        if total_abs > 0:
            for symbol in self.symbols:
                weights[symbol] = momentum[symbol] / total_abs
        else:
            # Equal weight if no signal
            for symbol in self.symbols:
                weights[symbol] = 1.0 / len(self.symbols)
        
        return weights
    
    def ApplyRiskManagement(self, weights: dict) -> dict:
        """
        Apply risk management constraints.
        
        Parameters
        ----------
        weights : dict
            Raw weights
            
        Returns
        -------
        dict
            Adjusted weights
        """
        # Check drawdown
        if self.Portfolio.TotalPortfolioValue > 0:
            current_dd = 1 - self.Portfolio.TotalPortfolioValue / self.Portfolio.TotalProfit
            if current_dd > self.max_drawdown:
                self.Debug(f"Drawdown limit reached: {{current_dd:.2%}}")
                return {{s: 0 for s in self.symbols}}
        
        # Apply leverage constraint
        total_weight = sum(abs(w) for w in weights.values())
        if total_weight > self.max_leverage:
            scale = self.max_leverage / total_weight
            weights = {{s: w * scale for s, w in weights.items()}}
        
        return weights
    
    def OnEndOfAlgorithm(self) -> None:
        """Called at end of backtest."""
        self.Debug(f"Final Portfolio Value: ${{self.Portfolio.TotalPortfolioValue:,.2f}}")
'''
        
        logger.info(f"Generated {len(code)} characters of LEAN code")
        return code
    
    def validate(self, returns: pd.Series) -> Dict[str, Any]:
        """
        Validate strategy meets Alpha Streams requirements.
        
        Parameters
        ----------
        returns : pd.Series
            Strategy returns
            
        Returns
        -------
        Dict[str, Any]
            Validation results
        """
        assert returns is not None, "Returns cannot be None"
        assert len(returns) > 0, "Returns cannot be empty"
        
        logger.info("Validating strategy for QuantConnect Alpha Streams")
        
        metrics = self._calculate_metrics(returns)
        
        # Calculate PSR
        psr = self._calculate_psr(returns, metrics['sharpe_ratio'])
        
        # Alpha Streams specific checks
        checks = {
            'psr_threshold': psr >= ALPHA_STREAMS_MIN_PSR,
            'positive_sharpe': metrics['sharpe_ratio'] > 0,
            'max_drawdown_ok': metrics['max_drawdown'] <= self.config.max_drawdown,
            'min_observations': len(returns) >= 252,  # 1 year minimum
        }
        
        passed = all(checks.values())
        
        result = {
            'passed': passed,
            'metrics': metrics,
            'psr': psr,
            'checks': checks,
            'platform': 'quantconnect',
            'alpha_streams_ready': passed and psr >= ALPHA_STREAMS_MIN_PSR,
        }
        
        if passed:
            logger.info(f"Strategy passed QC validation (PSR: {psr:.2%})")
        else:
            failed = [k for k, v in checks.items() if not v]
            logger.warning(f"Strategy failed QC validation: {failed}")
        
        return result
    
    def _calculate_psr(
        self,
        returns: pd.Series,
        sharpe: float,
        benchmark_sr: float = 0.0
    ) -> float:
        """
        Calculate Probabilistic Sharpe Ratio.
        
        Parameters
        ----------
        returns : pd.Series
            Strategy returns
        sharpe : float
            Observed Sharpe ratio
        benchmark_sr : float
            Benchmark Sharpe ratio
            
        Returns
        -------
        float
            PSR value (0 to 1)
        """
        try:
            n = len(returns)
            if n <= 1:
                return 0.0
            
            skew = returns.skew()
            kurt = returns.kurtosis()
            
            # Handle NaN values
            if np.isnan(skew):
                skew = 0.0
            if np.isnan(kurt):
                kurt = 3.0  # Normal distribution
            
            # Standard error of Sharpe ratio
            se_sr = np.sqrt(
                (1 - skew * sharpe + (kurt - 1) / 4 * sharpe**2) / (n - 1)
            )
            
            if se_sr <= 0 or np.isnan(se_sr):
                return 0.0
            
            # PSR
            z = (sharpe - benchmark_sr) / se_sr
            psr = stats.norm.cdf(z)
            
            return float(psr)
            
        except Exception as e:
            logger.warning(f"PSR calculation failed: {e}")
            return 0.0
    
    def deploy(self, code: str) -> DeploymentResult:
        """
        Deploy strategy to QuantConnect.
        
        Note: Actual deployment requires QuantConnect API or manual upload.
        
        Parameters
        ----------
        code : str
            LEAN algorithm code
            
        Returns
        -------
        DeploymentResult
            Deployment result with instructions
        """
        assert code is not None, "Code cannot be None"
        assert len(code) > 0, "Code cannot be empty"
        
        logger.info("Preparing QuantConnect deployment")
        
        filename = f"{self.config.strategy_name.replace(' ', '')}.py"
        
        return DeploymentResult(
            success=True,
            platform=PlatformType.QUANTCONNECT,
            strategy_name=self.config.strategy_name,
            message=f"LEAN algorithm generated. Upload {filename} to QuantConnect.",
            code=code,
            metadata={
                'filename': filename,
                'symbols': self.symbols,
                'resolution': self.resolution,
                'instructions': [
                    "1. Go to https://www.quantconnect.com",
                    "2. Create new algorithm",
                    "3. Paste generated code",
                    "4. Run backtest",
                    "5. Deploy to paper trading",
                    "6. After 3-6 months, submit to Alpha Streams",
                ],
                'alpha_streams_requirements': {
                    'min_psr': ALPHA_STREAMS_MIN_PSR,
                    'max_correlation': ALPHA_STREAMS_MAX_CORRELATION,
                    'min_capacity': ALPHA_STREAMS_MIN_CAPACITY,
                    'min_track_record': '3-6 months',
                },
            }
        )
