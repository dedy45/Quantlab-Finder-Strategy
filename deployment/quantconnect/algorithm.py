"""
QuantConnect Algorithm Templates.

Pre-built LEAN algorithm templates for common strategies.
"""

import logging
from typing import Dict

logger = logging.getLogger(__name__)


class AlgorithmTemplate:
    """
    Generator for QuantConnect algorithm templates.
    
    Provides ready-to-use LEAN algorithm code for common strategies.
    """
    
    @staticmethod
    def momentum(
        symbols: list,
        lookback: int = 20,
        rebalance: str = 'weekly',
        initial_capital: int = None
    ) -> str:
        """
        Generate momentum strategy template.
        
        Parameters
        ----------
        symbols : list
            List of symbols to trade
        lookback : int
            Lookback period for momentum calculation
        rebalance : str
            Rebalance frequency
        initial_capital : int, optional
            Initial capital (loaded from config if not provided)
            
        Returns
        -------
        str
            LEAN algorithm code
        """
        # Load default capital from config if not provided
        if initial_capital is None:
            try:
                from config import get_config
                initial_capital = int(get_config().backtest.initial_capital)
            except Exception:
                initial_capital = 100000  # Fallback
        
        symbols_str = ', '.join([f'"{s}"' for s in symbols])
        
        return f'''"""
Momentum Strategy - QuantConnect LEAN
Generated by QuantLab
"""
from AlgorithmImports import *
import numpy as np


class MomentumStrategy(QCAlgorithm):
    
    def Initialize(self):
        self.SetStartDate(2020, 1, 1)
        self.SetCash({initial_capital})
        
        self.symbols = [{symbols_str}]
        self.lookback = {lookback}
        
        for symbol in self.symbols:
            self.AddEquity(symbol, Resolution.Daily)
        
        self.Schedule.On(
            self.DateRules.Every(DayOfWeek.Monday),
            self.TimeRules.AfterMarketOpen("SPY", 30),
            self.Rebalance
        )
        
        self.SetWarmUp(self.lookback)
    
    def Rebalance(self):
        if self.IsWarmingUp:
            return
        
        momentum = {{}}
        for symbol in self.symbols:
            history = self.History(symbol, self.lookback, Resolution.Daily)
            if len(history) >= self.lookback:
                returns = history["close"].pct_change().dropna()
                momentum[symbol] = returns.mean()
            else:
                momentum[symbol] = 0
        
        # Long top performers, short bottom
        sorted_mom = sorted(momentum.items(), key=lambda x: x[1], reverse=True)
        n = len(sorted_mom)
        
        for i, (symbol, _) in enumerate(sorted_mom):
            if i < n // 3:  # Top third
                self.SetHoldings(symbol, 1.0 / (n // 3))
            elif i >= 2 * n // 3:  # Bottom third
                self.SetHoldings(symbol, -1.0 / (n // 3))
            else:
                self.SetHoldings(symbol, 0)
'''
    
    @staticmethod
    def mean_reversion(
        symbols: list,
        lookback: int = 20,
        entry_z: float = 2.0,
        exit_z: float = 0.5,
        initial_capital: int = None
    ) -> str:
        """
        Generate mean reversion strategy template.
        
        Parameters
        ----------
        symbols : list
            List of symbols to trade
        lookback : int
            Lookback period for z-score
        entry_z : float
            Z-score threshold for entry
        exit_z : float
            Z-score threshold for exit
        initial_capital : int, optional
            Initial capital (loaded from config if not provided)
            
        Returns
        -------
        str
            LEAN algorithm code
        """
        # Load default capital from config if not provided
        if initial_capital is None:
            try:
                from config import get_config
                initial_capital = int(get_config().backtest.initial_capital)
            except Exception:
                initial_capital = 100000  # Fallback
        
        symbols_str = ', '.join([f'"{s}"' for s in symbols])
        
        return f'''"""
Mean Reversion Strategy - QuantConnect LEAN
Generated by QuantLab
"""
from AlgorithmImports import *
import numpy as np


class MeanReversionStrategy(QCAlgorithm):
    
    def Initialize(self):
        self.SetStartDate(2020, 1, 1)
        self.SetCash({initial_capital})
        
        self.symbols = [{symbols_str}]
        self.lookback = {lookback}
        self.entry_z = {entry_z}
        self.exit_z = {exit_z}
        
        for symbol in self.symbols:
            self.AddEquity(symbol, Resolution.Daily)
        
        self.SetWarmUp(self.lookback)
    
    def OnData(self, data):
        if self.IsWarmingUp:
            return
        
        for symbol in self.symbols:
            if not data.ContainsKey(symbol):
                continue
            
            history = self.History(symbol, self.lookback, Resolution.Daily)
            if len(history) < self.lookback:
                continue
            
            prices = history["close"]
            mean = prices.mean()
            std = prices.std()
            
            if std == 0:
                continue
            
            current = data[symbol].Close
            zscore = (current - mean) / std
            
            holding = self.Portfolio[symbol].Quantity
            
            # Entry signals
            if zscore < -self.entry_z and holding <= 0:
                self.SetHoldings(symbol, 1.0 / len(self.symbols))
            elif zscore > self.entry_z and holding >= 0:
                self.SetHoldings(symbol, -1.0 / len(self.symbols))
            
            # Exit signals
            elif abs(zscore) < self.exit_z and holding != 0:
                self.Liquidate(symbol)
'''
    
    @staticmethod
    def dual_momentum(
        symbols: list,
        fast_period: int = 20,
        slow_period: int = 60,
        initial_capital: int = None
    ) -> str:
        """
        Generate dual momentum strategy template.
        
        Parameters
        ----------
        symbols : list
            List of symbols to trade
        fast_period : int
            Fast momentum period
        slow_period : int
            Slow momentum period
        initial_capital : int, optional
            Initial capital (loaded from config if not provided)
            
        Returns
        -------
        str
            LEAN algorithm code
        """
        # Load default capital from config if not provided
        if initial_capital is None:
            try:
                from config import get_config
                initial_capital = int(get_config().backtest.initial_capital)
            except Exception:
                initial_capital = 100000  # Fallback
        
        symbols_str = ', '.join([f'"{s}"' for s in symbols])
        
        return f'''"""
Dual Momentum Strategy - QuantConnect LEAN
Generated by QuantLab
"""
from AlgorithmImports import *
import numpy as np


class DualMomentumStrategy(QCAlgorithm):
    
    def Initialize(self):
        self.SetStartDate(2020, 1, 1)
        self.SetCash({initial_capital})
        
        self.symbols = [{symbols_str}]
        self.fast_period = {fast_period}
        self.slow_period = {slow_period}
        
        # Add safe asset
        self.safe_asset = "TLT"
        self.AddEquity(self.safe_asset, Resolution.Daily)
        
        for symbol in self.symbols:
            self.AddEquity(symbol, Resolution.Daily)
        
        self.Schedule.On(
            self.DateRules.MonthStart(),
            self.TimeRules.AfterMarketOpen("SPY", 30),
            self.Rebalance
        )
        
        self.SetWarmUp(self.slow_period)
    
    def Rebalance(self):
        if self.IsWarmingUp:
            return
        
        # Calculate absolute momentum (time-series)
        abs_momentum = {{}}
        for symbol in self.symbols:
            history = self.History(symbol, self.slow_period, Resolution.Daily)
            if len(history) >= self.slow_period:
                ret = (history["close"].iloc[-1] / history["close"].iloc[0]) - 1
                abs_momentum[symbol] = ret
            else:
                abs_momentum[symbol] = 0
        
        # Filter: only positive absolute momentum
        positive = {{k: v for k, v in abs_momentum.items() if v > 0}}
        
        if not positive:
            # All negative, go to safe asset
            self.Liquidate()
            self.SetHoldings(self.safe_asset, 1.0)
            return
        
        # Relative momentum: rank by fast momentum
        rel_momentum = {{}}
        for symbol in positive:
            history = self.History(symbol, self.fast_period, Resolution.Daily)
            if len(history) >= self.fast_period:
                ret = (history["close"].iloc[-1] / history["close"].iloc[0]) - 1
                rel_momentum[symbol] = ret
        
        # Select top performer
        if rel_momentum:
            best = max(rel_momentum, key=rel_momentum.get)
            self.Liquidate()
            self.SetHoldings(best, 1.0)
'''
    
    @staticmethod
    def get_templates() -> Dict[str, callable]:
        """Get all available templates."""
        return {
            'momentum': AlgorithmTemplate.momentum,
            'mean_reversion': AlgorithmTemplate.mean_reversion,
            'dual_momentum': AlgorithmTemplate.dual_momentum,
        }
